# MustLearnToday

**记录需要立马学习但暂时还未学习的零碎知识点。**

函数式编程：
[谈谈 Swift 中的 map 和 flatMap](http://www.cocoachina.com/swift/20160527/16467.html)

枚举：[枚举（Enumerations）](http://wiki.jikexueyuan.com/project/swift/chapter2/08_Enumerations.html)

集合：[深入探究Swift数组背后的协议、方法、拓展](http://www.cocoachina.com/ios/20151218/14716.html)

[Swift性能相关](http://www.jianshu.com/p/0d3db4422954?url_type=39&object_type=webpage&pos=1)

[根据IOS Foundation框架汇编反写的KVC,KVO实现](https://github.com/renjinkui2719/DIS_KVC_KVO)


Swift构造器：[构造过程](http://wiki.jikexueyuan.com/project/swift/chapter2/14_Initialization.html)  
**构造器：**是使用类、结构体和枚举类型的实例之前必须执行的准备工作。  
具体操作包括设置实例中每个存储属性的初始值和执行其他必须的设置或初始化工作。  
通过定义构造器来实现构造过程，这些构造器可以看做是用来创建特殊类型新实例的特殊方法。  
与OC中的构造器不同，Swift中的构造器无需返回值，他们的主要任务是保证新实例在第一次使用前完成正确的初始化。

类和结构体在创建实例时，必须为所有属性设置合适的初始值。   
可以在构造器中设置初始值，也可以在定义属性时为其设置默认值。  
当为存储属性设置默认值或在构造器赋值时，它的值是被直接设置的，不会触发任何属性观察者。  

对于类的实例来说，它的常量属性只能在定义它的类的构造过程中修改，不能在子类中修改。  
一旦常量属性被赋值，它将永远不可被修改。  

**构造器代理**   

构造器能通过调用其他构造器来完成实例的部分构造过程。这一过程称为构造器代理，他能减少多个构造器之间的重复代码。  

构造器代理的实现规则和形式在值类型和类类型中有所不同。值类型不能继承，所以他的构造器只能代理给自己的其他构造器；类可以继承，这就意味着类在构造过程中要保证其所继承的所有存储属性都能够正确的完成初始化。  

对于值类型：  
当为值类型自定义了一个构造器，值类型原有的默认构造期（包括结构体的逐一成员构造器）将无法使用，这是为了防止当定义了一个比较负责的构造器之后仍有使用者调用原有的构造器从而引起错误。 如果仍想要保证原有的默认构造器可以使用，可以将自定义的构造器函数定义在分类里面。   

对于类类型：  
Swift提供了两种构造器来保证类实例的所有属性都能获得初始值。它们分别是指定构造器（designated）和便利构造器（convenience）。  
在每一个类中必须拥有一个指定构造器，许多类由于继承关系而满足了这个条件。  

```
// 指定构造器的写法与值类型的构造器写法相似
init(parameters) {
    statements
}
// 便利构造器前须加上convenience关键字
convenience init(parameters) {
    statements
}
```
类的构造器代理规则：  

1. 指定构造器必须调用其直接父类的指定构造器；
2. 便利构造器必须调用同类中的构造器；
3. 便利构造器最终必须导致同类中一个指定构造器的调用。  

* 指定构造器必须向上代理；
* 便利构造器必须横向代理。

基于以上原则，不难推断出：  

1. 当在自类中编写一个和父类中的指定构造器相匹配的构造器时，实际上是重写父类的这个指定构造器，需要加上override关键字；
2. 便利构造器不能继承，子类中即使写了和父类中相同的便利构造器，实际上也算不上是对父类中便利构造器的继承，因为它不会调用到父类的便利构造器；
3. Swift中的字类默认情况下不会默认继承父类的构造器，所以在字类中自定义便利构造器时，需重写父类中的指定构造器。

两段式构造过程：   
##### 什么是两段式构造过程？  

1. 第一个阶段：在指定构造器调用父类的构造函数之前；每个存储属性被引入他们的类指定一个初始值。
2. 第二个阶段：在新实例使用之前，进一步定制它的存储属性。

##### 为什么要引入两段式构造过程？  

更安全，更灵活。  
防止属性在初始话之前被使用，防止属性被另外的构造器恶意的修改。同时在整个类的层级结构中给予了每个类最大的灵活性。  

##### 四种有效的安全检查

1. 指定构造器必须先将其引入的存储属性初始化完成之后，才能将其他构造任务向上代理给父类中的构造器。 
2. 指定构造器必须先向上代理父类中的构造器，然后再为继承的属性设置新值。
3. 便利构造器必须先同一类中的其他构造器，然后再为任意属性赋新值。
4. 构造器在第一阶段完成之前，类实例不是完全有效的，不能访问属性和调用实例方法，第一阶段完成之后，才能够成为有效实例。

构造器的自动继承：  
子类默认情况下不会继承父类的构造器，但满足以下条件父类构造器是可以被默认继承的。  

假设你为子类中引入的所有新属性都设置了默认值，以下两个规则适用：  

1. 如果子类没有定义任何指定构造器，它将继承所有父类的指定构造器；  
2. 如果子类提供了所有父类指定构造器的实现，无论是通过规则1继承过来的，还是提供了自定义实现，它将自动继承所有父类的便利构造器。


