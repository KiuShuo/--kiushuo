# 多线程

### GCD

参考资料：  
[基本概念](http://www.jianshu.com/p/678eb2c3b7cb)  
[GCD in Swift 3](http://www.jianshu.com/p/7efbecee6af8)  
[深入理解 GCD](http://www.jianshu.com/p/06a18323d9d2)    

#### 是什么？

#### 能干什么？

#### 基本概念
任务、队列queue、同步sync、异步async  
任务是一个比较抽象的概念，表示一段用来执行的代码，对应到代码里面一般指的是一个block或者一个函数。GCD中任务是通过block进行封装的，并且任务block没有参数也没有返回值。  

| | 描述|是否开线程|
|---|---|---|
|同步 |必须执行完同步里面的代码，再执行下面的 | 不具备开线程的能力 |
|异步 |先执行后面的代码，我再找线程去执行我里面的代码 | 有开线程的能力，但是不一定开；需要根据具体的队列来判断是否开线程 |


#### GCD的使用步骤：
1. 创建／获取 一个队列；
2. 创建任务；
3. 将任务添加到队列里面:  
	* GCD会自动的将队列中的任务取出，放到对应的线程中执行；
	* 任务的取出遵循队列的FIFO原则：先进先出，后进后出。

#### 队列  
队列包含串行队列、并发队列、主队列、并发队列  

| 类型 | 特点 | 同步sync执行 | 异步async执行 |  
|---|---|---|---|
| 串行队列 Serial Dispatch Queue | 以先进先出的方式，按顺序调度队列中的任务执行，一次只能调度一个任务。</br>无论串行队列中的任务函数是同步的还是异步的，都必须等待前一个任务执行完毕，才可以执行后面的任务。  |不开线程，顺序执行 |开一个线程，顺序执行|
| 并行队列 Concurrent Dispath Queue | 1. 以先进先出的方式，并发（同时）调度队列中的任务去执行;</br> 2. 如果当前调度的任务是同步执行，会等待当前的任务执行完毕，再调度后续的任务执行；</br> 3.如果当前的任务是异步执行，并且线程池中有可用的资源，则不会等待当前任务，直接调度任务到新线程中执行。 | 不开线程，顺序执行 | 开多个线程，无序执行 |
| 主队列 Main Queue | 1.添加到主队列中的任务只能在主线程中执行；</br> 2.以先进先出的方式，只有当主线程中的代码执行完毕之后，主队列才会调度任务到主线程。| 死锁。由于是同步执行，所以需要等主队列中的任务执行完毕以后才会执行后面的代码；而主队列中的任务又需要等待主线程中的任务执行完毕以后才能执行；这样就形成了相互等待，引起死锁。 | 不开线程，顺序执行，先把主线程中的代码执行完之后，才会执行添加到主队列中的任务 |
| 全局队列 Global Queue | 全局队列是系统为了程序员方便，提供的一种特殊的并行队列 | 同并行队列的区别：</br> 1.全局队列没有名称，无论是ARC还是MRC都不需要考虑内存释放，日常开发中建议使用；</br> 2.并行队列有名称，在MRC下需要调用dispatch*_*release进行释放; </br> dispatch*_*barrier必须使用自定以的并发队列：</br> 开发第三方框架建议使用并发队列。|

#### 获取队列
`dispatch_get_main_queue()`
`dispatch_get_global_queue()`
#### 创建队列
```
dispatch_queue_creat
```

#### Question
1. 在GCD队列中添加的任务block中使用self会引起循环引用吗？  
	答：不会。因为block虽然会对里面的代码进行copy操作从而对self保持一份引用，但self对block却没有持有。持有block的是系统，所以不会引起循环引用。




###### ...以下为待整理内容
#### iOS几种多线程的区别： 
iOS中的多线程技术主要有NSThread, GCD和NSOperation。他们的封装层次依次递增，其中：

NSThread封装性最差，最偏向于底层，主要基于thread使用
GCD是基于C的API，直接使用比较方便，主要基于task使用
NSOperation是基于GCD封装的NSObject对象，对于复杂的多线程项目使用比较方便，主要基于队列使用
