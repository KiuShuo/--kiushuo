#内存管理
// 已学习...  
[理解 iOS 的内存管理](http://blog.devtang.com/2016/07/30/ios-memory-management/)  
[Swift自动引用计数](http://wiki.jikexueyuan.com/project/swift/chapter2/16_Automatic_Reference_Counting.html)  
[如何理解iOS的ARC和ARC的实现原理](http://www.jianshu.com/p/a512b19d8729)  

// 待学习...  
[Swift3——Swift内存管理](https://icocos.github.io/2017/05/23/Swift3%E2%80%94%E2%80%94Swift%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/)  
[iOS内功篇：内存管理](http://www.jianshu.com/p/8b1ed04b3ba9)  
[iOS实录15：浅谈iOS Crash（二）](http://www.bijishequ.com/detail/428584?p=)  
[ARC 下内存泄露的那些点](https://www.zybuluo.com/MicroCai/note/67734)  

## ARC 的内部实现

[65]页

###### 内存管理的原理
通过引用计数来管理内存  
Swift通过自动引用计数(ARC)的机制来追踪和管理应用程序的内存（在 Compile Sources 中对 Swift 文件的 Compile Flags 中添加 -fno-objc-arc 标记无效）。

###### 内存管理的原则
* 自己生成的对象 自己持有
* 非自己生成的对象 自己也能持有
* 自己持有的对象不再需要时自己释放
* 非自己持有的对象 自己不能释放

###### 引用计数
引用计数(Reference Counting)是一种简单而有效的管理对象生命周期的方式。  
包含：手动引用计数（MRC: Manual Reference Counting） 自动引用计数(ARC: Automatic Reference Counting)

当我们创建一个新的对象的时候，它的引用计数为1；  
当有新的强指针指向这个对象的时候，他的引用计数+1；  
当有一个强指针不再指向这个对象的时候，他的引用计数-1；  
当引用计数为0时，这个对象会被释放。    
引用计数并非Objective-C Swift独有，像微软的COM C++11等语言也提供了关于引用计数的内存管理方式。

###### ARC 的原理
引用计数的内存管理方式虽然简单，但手工大量的操作引用计数不仅繁琐而且容易遗漏。于是苹果在2011年引入了自动引用计数ARC。  
ARC的想法来源于苹果早期设计Xcode的Analyzer的时候，发现编译器在编译的时候会发现代码中的很多内存问题。后来苹果想能不能在编译的时候把内存管理的代码自动补上，带着这种想法，苹果就修改了内存管理代码的书写方式，也就是后来的ARC。  
ARC的原理：当我们编译代码的时候，编译器会分析代码中每个对象的生命周期，然后基于这些对象的生命周期，自动的添加响应的引用计数的代码。所以，ARC是工作在编译器的一种工作方案。  
实际上，由于 ARC 在编译期自动添加了引用计数的代码，所以编译之后，ARC和MRC的代码没有区别，这也是二者可以混编的原因。  
在 Objective-C 工程 target -> Build Phases(编译阶段) -> Compile Sources(编译源) 中修改相应文件的 Compile Flags(编译标记) 即可实现 ARC 与 MRC 的混编。 ARC 项目中可以通过添加编译参数 -fno-objc-arc 来关闭部分文件的ARC功能；MRC 项目中可以通过添加编译参数 -fobjc-arc 来打开部分文件的ARC功能。通过这个操作也可以反正出 ARC 是在编译期添加进行内存管理代码的添加操作的。

###### autorelease的工作原理
常用的便利构造器方法，实际上就是将生成的对象添加到了自动释放池中。  

```
@interface A : NSObject

+ (instancetype)object;

@end

@implementation A

+ (instancetype)object {
    A *a = [A alloc];
    [a autorelease]; // autorelease自动释放内存 会在一个RunLoop结束的时候释放
    /*
     调用autorelease的实例，会在超出其作用域时执行其release方法。
     autorelease的具体使用方法如下：
     // 1.生成并持有NSAutoreleasePool对象
     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
     id object0 = [[NSObject alloc] init];
     // 2.调用分配对象的autorelease方法
     [object0 autorelease];
     // 3.废弃NSAutoreleasePool对象 在废弃的同时，系统会调用object的release方法
     [pool drain];
     
     在Cocoa框架中，相当于程序主循环的NSRunLoop或者其他程序可运行的地方，对NSAutoreleasePool对象进行生成、持有和废弃处理。因此，绝大部分时候，开发者不需要自己写NSAutoreleasePool的相关代码。
     // autorelease实例方法的本质就是调用NSAutoreleasePool对象的addObjec类方法
     // autorelease的内部实现
     - (instancetype)autorelease {
        [NSAutoreleasePool addObject:self];
     }
     NSAutoreleasePool的类方法 + (void)addObject:(NSObject *)obj 的内部实现：
     + (void)addObject:(NSObject *)obj {
        NSAutoreleasePool *currentAutoreleasePool = [获取当前的NSAutoreleasePool对象];
        [currentAutoreleasePool addObject: obj]; // 调用NSAutoreleasePool对象的实例方法
     }
     NSAutoreleasePool的实例方法 - (void)addObject:(NSObject *)obj 的内部实现：
     - (void)addObject:(NSObject *)obj {
        [mArray addObject:obj]; // 用一个可变数组存储obj
     }
     drain的内部实现：
     - (void)drain {
        [self release];
        [mArray release];
     }
     - (void)dealloc {
        for (obj in mArray) {
            [obj release];
        }
     }
     */
    
    /*
     不能调用NSAutoreleasePool对象的autorelease方法
     在Foundation框架中，无论调用哪个对象的autorelease方法，都是调用NSObject类的autorelease方法；但对于NSAutoreleasePool类，autorelease实例方法已经被该类重载，因此运行时会出错。
     
     */
    
    return a;
}

@end
```

###### block属性的关键词使用copy 在Swift中默认又是什么呢

###### 开发中常见的内存问题
内存泄漏：应当废弃的对象在超出其生命周期后继续存在，如循环引用就会造成内存泄漏。  

* 循环引用：可以是两个对象之间循环引用，也可以是一个对象引起的循环引用（在A类中有一个属性A *a；或者有一个block属性；将A()赋值给了a属性／在block属性中使用了self 都会引起循环引用）。  
* 

###### 弱引用和无主引用都可以解决循环强引用问题，二者又什么区别？

弱引用和无主引用允许循环引用中的一个实例引用另外一个实例，但不保持强引用。这样实例能够相互引用而不产生循环强引用。  

因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。因此，ARC会在引用的实例被销毁后自动将其置为nil。并且因为弱引用可以允许它们的值在运行时被赋值为nil，所以它们会被定义为可选类型变量，而不是常量。  
==当 ARC 设置弱引用为nil时，属性观察不会被触发。==

无主引用通常都被期望拥有值。不过 ARC 无法在实例被销毁后将无主引用设为nil，因为非可选类型的变量不允许被赋值为nil。  
==使用无主引用，你必须确保引用始终指向一个未销毁的实例。  
如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。==

当其他实例有更短的生命周期时，使用弱引用。  
无主引用在其他实例有相同或更长生命周期时使用。  
例如：租客Person相对于公寓Apartment来说，由于公寓在某段时间内可能没有租客，所以租客的生命周期更短；持卡人Customer相对于信用卡CreditCard来说，由于信用卡必须被持卡人持有，所以持卡人的生命周期更长。  

Person和Apartment的例子展示了两个属性的值都允许为nil，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。

Customer和CreditCard的例子展示了一个属性的值允许为nil，而另一个属性的值不允许为nil，这也可能会产生循环强引用。这种场景最适合通过无主引用来解决。  

存在着第三种场景，在这种场景中，两个属性都必须有值，并且初始化完成后永远不会为nil。在这种场景中，需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。   


在闭包和捕获的实例总是互相引用并且总是同时销毁时，将闭包内的捕获定义为无主引用。

相反的，在被捕获的引用可能会变为nil时，将闭包内的捕获定义为弱引用。弱引用总是可选类型，并且当引用的实例被销毁后，弱引用的值会自动置为nil。这使我们可以在闭包体内检查它们是否存在。

==如果被捕获的引用绝对不会变为nil，应该用无主引用，而不是弱引用。==
